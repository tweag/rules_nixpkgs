"""Rules for importing Nixpkgs packages."""

load("@bazel_skylib//lib:sets.bzl", "sets")
load("@bazel_skylib//lib:versions.bzl", "versions")
load("@bazel_tools//tools/cpp:cc_configure.bzl", "cc_autoconf_impl")
load(
    "@bazel_tools//tools/cpp:lib_cc_configure.bzl",
    "get_cpu_value",
    "get_starlark_list",
    "write_builtin_include_directory_paths",
)
load("@bazel_tools//tools/build_defs/repo:utils.bzl", "maybe")
load(
    "@rules_nixpkgs_core//:nixpkgs.bzl",
    _nixpkgs_git_repository = "nixpkgs_git_repository",
    _nixpkgs_local_repository = "nixpkgs_local_repository",
    _nixpkgs_package = "nixpkgs_package",
)
load(
    "//toolchains/python:python.bzl",
    _nixpkgs_python_configure = "nixpkgs_python_configure",
)
load(
    "@rules_nixpkgs_core//:util.bzl",
    "ensure_constraints",
    "execute_or_fail",
    "find_children",
    "is_supported_platform",
)

# aliases for backwards compatibility prior to `bzlmod`
nixpkgs_git_repository = _nixpkgs_git_repository
nixpkgs_local_repository = _nixpkgs_local_repository
nixpkgs_package = _nixpkgs_package
nixpkgs_python_configure = _nixpkgs_python_configure

def _parse_cc_toolchain_info(content, filename):
    """Parses the `CC_TOOLCHAIN_INFO` file generated by Nix.

    Attrs:
      content: string, The content of the `CC_TOOLCHAIN_INFO` file.
      filename: string, The path to the `CC_TOOLCHAIN_INFO` file, used for error reporting.

    Returns:
      struct, The substitutions for `@bazel_tools//tools/cpp:BUILD.tpl`.
    """

    # Parse the content of CC_TOOLCHAIN_INFO.
    #
    # Each line has the form
    #
    #   <key>:<value1>:<value2>:...
    info = {}
    for line in content.splitlines():
        fields = line.split(":")
        if len(fields) == 0:
            fail(
                "Malformed CC_TOOLCHAIN_INFO '{}': Empty line encountered.".format(filename),
                "cc_toolchain_info",
            )
        info[fields[0]] = fields[1:]

    # Validate the keys in CC_TOOLCHAIN_INFO.
    expected_keys = sets.make([
        "TOOL_NAMES",
        "TOOL_PATHS",
        "CXX_BUILTIN_INCLUDE_DIRECTORIES",
        "COMPILE_FLAGS",
        "CXX_FLAGS",
        "LINK_FLAGS",
        "LINK_LIBS",
        "OPT_COMPILE_FLAGS",
        "OPT_LINK_FLAGS",
        "UNFILTERED_COMPILE_FLAGS",
        "DBG_COMPILE_FLAGS",
        "COVERAGE_COMPILE_FLAGS",
        "COVERAGE_LINK_FLAGS",
        "SUPPORTS_START_END_LIB",
        "IS_CLANG",
    ])
    actual_keys = sets.make(info.keys())
    missing_keys = sets.difference(expected_keys, actual_keys)
    unexpected_keys = sets.difference(actual_keys, expected_keys)
    if sets.length(missing_keys) > 0:
        fail(
            "Malformed CC_TOOLCHAIN_INFO '{}': Missing entries '{}'.".format(
                filename,
                "', '".join(sets.to_list(missing_keys)),
            ),
            "cc_toolchain_info",
        )
    if sets.length(unexpected_keys) > 0:
        fail(
            "Malformed CC_TOOLCHAIN_INFO '{}': Unexpected entries '{}'.".format(
                filename,
                "', '".join(sets.to_list(unexpected_keys)),
            ),
            "cc_toolchain_info",
        )

    return struct(
        tool_paths = {
            tool: path
            for (tool, path) in zip(info["TOOL_NAMES"], info["TOOL_PATHS"])
        },
        cxx_builtin_include_directories = info["CXX_BUILTIN_INCLUDE_DIRECTORIES"],
        compile_flags = info["COMPILE_FLAGS"],
        cxx_flags = info["CXX_FLAGS"],
        link_flags = info["LINK_FLAGS"],
        link_libs = info["LINK_LIBS"],
        opt_compile_flags = info["OPT_COMPILE_FLAGS"],
        opt_link_flags = info["OPT_LINK_FLAGS"],
        unfiltered_compile_flags = info["UNFILTERED_COMPILE_FLAGS"],
        dbg_compile_flags = info["DBG_COMPILE_FLAGS"],
        coverage_compile_flags = info["COVERAGE_COMPILE_FLAGS"],
        coverage_link_flags = info["COVERAGE_LINK_FLAGS"],
        supports_start_end_lib = info["SUPPORTS_START_END_LIB"] == ["True"],
        is_clang = info["IS_CLANG"] == ["True"],
    )

def _nixpkgs_cc_toolchain_config_impl(repository_ctx):
    cpu_value = get_cpu_value(repository_ctx)
    darwin = cpu_value == "darwin"

    cc_toolchain_info_file = repository_ctx.path(repository_ctx.attr.cc_toolchain_info)
    if not cc_toolchain_info_file.exists and not repository_ctx.attr.fail_not_supported:
        return
    info = _parse_cc_toolchain_info(
        repository_ctx.read(cc_toolchain_info_file),
        cc_toolchain_info_file,
    )

    # Generate the cc_toolchain workspace following the example from
    # `@bazel_tools//tools/cpp:unix_cc_configure.bzl`.
    # Uses the corresponding templates from `@bazel_tools` as well, see the
    # private attributes of the `_nixpkgs_cc_toolchain_config` rule.
    repository_ctx.symlink(
        repository_ctx.path(repository_ctx.attr._unix_cc_toolchain_config),
        "cc_toolchain_config.bzl",
    )
    repository_ctx.symlink(
        repository_ctx.path(repository_ctx.attr._armeabi_cc_toolchain_config),
        "armeabi_cc_toolchain_config.bzl",
    )

    # A module map is required for clang starting from Bazel version 3.3.0.
    # https://github.com/bazelbuild/bazel/commit/8b9f74649512ee17ac52815468bf3d7e5e71c9fa
    needs_module_map = info.is_clang and versions.is_at_least("3.3.0", versions.get())
    if needs_module_map:
        generate_system_module_map = [
            repository_ctx.path(repository_ctx.attr._generate_system_module_map),
        ]
        repository_ctx.file(
            "module.modulemap",
            execute_or_fail(
                repository_ctx,
                generate_system_module_map + info.cxx_builtin_include_directories,
                "Failed to generate system module map.",
            ).stdout.strip(),
            executable = False,
        )
    cc_wrapper_src = (
        repository_ctx.attr._osx_cc_wrapper if darwin else repository_ctx.attr._linux_cc_wrapper
    )
    repository_ctx.template(
        "cc_wrapper.sh",
        repository_ctx.path(cc_wrapper_src),
        {
            "%{cc}": info.tool_paths["gcc"],
            "%{env}": "",
        },
    )
    if darwin:
        info.tool_paths["gcc"] = "cc_wrapper.sh"
        info.tool_paths["ar"] = "/usr/bin/libtool"
    write_builtin_include_directory_paths(
        repository_ctx,
        info.tool_paths["gcc"],
        info.cxx_builtin_include_directories,
    )
    repository_ctx.template(
        "BUILD.bazel",
        repository_ctx.path(repository_ctx.attr._build),
        {
            "%{cc_toolchain_identifier}": "local",
            "%{name}": cpu_value,
            "%{modulemap}": ("\":module.modulemap\"" if needs_module_map else "None"),
            "%{supports_param_files}": "0" if darwin else "1",
            "%{cc_compiler_deps}": get_starlark_list(
                [":builtin_include_directory_paths"] + (
                    [":cc_wrapper"] if darwin else []
                ),
            ),
            "%{compiler}": "compiler",
            "%{abi_version}": "local",
            "%{abi_libc_version}": "local",
            "%{host_system_name}": "local",
            "%{target_libc}": "macosx" if darwin else "local",
            "%{target_cpu}": cpu_value,
            "%{target_system_name}": "local",
            "%{tool_paths}": ",\n        ".join(
                ['"%s": "%s"' % (k, v) for (k, v) in info.tool_paths.items()],
            ),
            "%{cxx_builtin_include_directories}": get_starlark_list(info.cxx_builtin_include_directories),
            "%{compile_flags}": get_starlark_list(info.compile_flags),
            "%{cxx_flags}": get_starlark_list(info.cxx_flags),
            "%{link_flags}": get_starlark_list(info.link_flags),
            "%{link_libs}": get_starlark_list(info.link_libs),
            "%{opt_compile_flags}": get_starlark_list(info.opt_compile_flags),
            "%{opt_link_flags}": get_starlark_list(info.opt_link_flags),
            "%{unfiltered_compile_flags}": get_starlark_list(info.unfiltered_compile_flags),
            "%{dbg_compile_flags}": get_starlark_list(info.dbg_compile_flags),
            "%{coverage_compile_flags}": get_starlark_list(info.coverage_compile_flags),
            "%{coverage_link_flags}": get_starlark_list(info.coverage_link_flags),
            "%{supports_start_end_lib}": repr(info.supports_start_end_lib),
        },
    )

_nixpkgs_cc_toolchain_config = repository_rule(
    _nixpkgs_cc_toolchain_config_impl,
    attrs = {
        "cc_toolchain_info": attr.label(),
        "fail_not_supported": attr.bool(),
        "_unix_cc_toolchain_config": attr.label(
            default = Label("@bazel_tools//tools/cpp:unix_cc_toolchain_config.bzl"),
        ),
        "_armeabi_cc_toolchain_config": attr.label(
            default = Label("@bazel_tools//tools/cpp:armeabi_cc_toolchain_config.bzl"),
        ),
        "_generate_system_module_map": attr.label(
            default = Label("@bazel_tools//tools/cpp:generate_system_module_map.sh"),
        ),
        "_osx_cc_wrapper": attr.label(
            default = Label("@bazel_tools//tools/cpp:osx_cc_wrapper.sh.tpl"),
        ),
        "_linux_cc_wrapper": attr.label(
            default = Label("@bazel_tools//tools/cpp:linux_cc_wrapper.sh.tpl"),
        ),
        "_build": attr.label(
            default = Label("@bazel_tools//tools/cpp:BUILD.tpl"),
        ),
    },
)

def _nixpkgs_cc_toolchain_impl(repository_ctx):
    cpu = get_cpu_value(repository_ctx)
    exec_constraints, target_constraints = ensure_constraints(repository_ctx)

    repository_ctx.file(
        "BUILD.bazel",
        executable = False,
        content = """\
package(default_visibility = ["//visibility:public"])

toolchain(
    name = "cc-toolchain-{cpu}",
    toolchain = "@{cc_toolchain_config}//:cc-compiler-{cpu}",
    toolchain_type = "@rules_cc//cc:toolchain_type",
    exec_compatible_with = {exec_constraints},
    target_compatible_with = {target_constraints},
)

toolchain(
    name = "cc-toolchain-armeabi-v7a",
    toolchain = "@{cc_toolchain_config}//:cc-compiler-armeabi-v7a",
    toolchain_type = "@rules_cc//cc:toolchain_type",
    exec_compatible_with = {exec_constraints},
    target_compatible_with = [
        "@platforms//cpu:arm",
        "@platforms//os:android",
    ],
)
""".format(
            cc_toolchain_config = repository_ctx.attr.cc_toolchain_config,
            cpu = cpu,
            exec_constraints = exec_constraints,
            target_constraints = target_constraints,
        ),
    )

_nixpkgs_cc_toolchain = repository_rule(
    _nixpkgs_cc_toolchain_impl,
    attrs = {
        "cc_toolchain_config": attr.string(),
        "exec_constraints": attr.string_list(),
        "target_constraints": attr.string_list(),
    },
)

def nixpkgs_cc_configure(
        name = "local_config_cc",
        attribute_path = "",
        nix_file = None,
        nix_file_content = "",
        nix_file_deps = [],
        repositories = {},
        repository = None,
        nixopts = [],
        quiet = False,
        fail_not_supported = True,
        exec_constraints = None,
        target_constraints = None,
        register = True):
    """Use a CC toolchain from Nixpkgs. No-op if not a nix-based platform.

    By default, Bazel auto-configures a CC toolchain from commands (e.g.
    `gcc`) available in the environment. To make builds more hermetic, use
    this rule to specify explicitly which commands the toolchain should use.

    Specifically, it builds a Nix derivation that provides the CC toolchain
    tools in the `bin/` path and constructs a CC toolchain that uses those
    tools. Tools that aren't found are replaced by `${coreutils}/bin/false`.
    You can inspect the resulting `@<name>_info//:CC_TOOLCHAIN_INFO` to see
    which tools were discovered.

    This rule depends on [`rules_cc`](https://github.com/bazelbuild/rules_cc).

    **Note:**
    You need to configure `--crosstool_top=@<name>//:toolchain` to activate
    this toolchain.

    Args:
      attribute_path: optional, string, Obtain the toolchain from the Nix expression under this attribute path. Requires `nix_file` or `nix_file_content`.
      nix_file: optional, Label, Obtain the toolchain from the Nix expression defined in this file. Specify only one of `nix_file` or `nix_file_content`.
      nix_file_content: optional, string, Obtain the toolchain from the given Nix expression. Specify only one of `nix_file` or `nix_file_content`.
      nix_file_deps: optional, list of Label, Additional files that the Nix expression depends on.
      repositories: dict of Label to string, Provides `<nixpkgs>` and other repositories. Specify one of `repositories` or `repository`.
      repository: Label, Provides `<nixpkgs>`. Specify one of `repositories` or `repository`.
      nixopts: optional, list of string, Extra flags to pass when calling Nix. Subject to location expansion, any instance of `$(location LABEL)` will be replaced by the path to the file ferenced by `LABEL` relative to the workspace root.
      quiet: bool, Whether to hide `nix-build` output.
      fail_not_supported: bool, Whether to fail if `nix-build` is not available.
      exec_constraints: Constraints for the execution platform.
      target_constraints: Constraints for the target platform.
      register: bool, enabled by default, Whether to register (with `register_toolchains`) the generated toolchain and install it as the default cc_toolchain.
    """

    nixopts = list(nixopts)
    nix_file_deps = list(nix_file_deps)

    nix_expr = None
    if nix_file and nix_file_content:
        fail("Cannot specify both 'nix_file' and 'nix_file_content'.")
    elif nix_file:
        nix_expr = "import $(location {})".format(nix_file)
        nix_file_deps.append(nix_file)
    elif nix_file_content:
        nix_expr = nix_file_content

    if attribute_path and nix_expr == None:
        fail("'attribute_path' requires one of 'nix_file' or 'nix_file_content'", "attribute_path")
    elif attribute_path:
        nixopts.extend([
            "--argstr",
            "ccType",
            "ccTypeAttribute",
            "--argstr",
            "ccAttrPath",
            attribute_path,
            "--arg",
            "ccAttrSet",
            nix_expr,
        ])
    elif nix_expr:
        nixopts.extend([
            "--argstr",
            "ccType",
            "ccTypeExpression",
            "--arg",
            "ccExpr",
            nix_expr,
        ])
    else:
        nixopts.extend([
            "--argstr",
            "ccType",
            "ccTypeDefault",
        ])

    # Invoke `toolchains/cc.nix` which generates `CC_TOOLCHAIN_INFO`.
    nixpkgs_package(
        name = "{}_info".format(name),
        nix_file = "@io_tweag_rules_nixpkgs//nixpkgs:toolchains/cc.nix",
        nix_file_deps = nix_file_deps,
        build_file_content = "exports_files(['CC_TOOLCHAIN_INFO'])",
        repositories = repositories,
        repository = repository,
        nixopts = nixopts,
        quiet = quiet,
        fail_not_supported = fail_not_supported,
    )

    # Generate the `cc_toolchain_config` workspace.
    _nixpkgs_cc_toolchain_config(
        name = "{}".format(name),
        cc_toolchain_info = "@{}_info//:CC_TOOLCHAIN_INFO".format(name),
        fail_not_supported = fail_not_supported,
    )

    # Generate the `cc_toolchain` workspace.
    if (exec_constraints == None) != (target_constraints == None):
        fail("Both exec_constraints and target_constraints need to be provided or none of them.")
    _nixpkgs_cc_toolchain(
        name = "{}_toolchains".format(name),
        cc_toolchain_config = name,
        exec_constraints = exec_constraints,
        target_constraints = target_constraints,
    )

    if register:
        maybe(
            native.bind,
            name = "cc_toolchain",
            actual = "@{}//:toolchain".format(name),
        )
        native.register_toolchains("@{}_toolchains//:all".format(name))

def _readlink(repository_ctx, path):
    return repository_ctx.path(path).realpath

def nixpkgs_cc_autoconf_impl(repository_ctx):
    cpu_value = get_cpu_value(repository_ctx)
    if not is_supported_platform(repository_ctx):
        cc_autoconf_impl(repository_ctx)
        return

    # Calling repository_ctx.path() on anything but a regular file
    # fails. So the roundabout way to do the same thing is to find
    # a regular file we know is in the workspace (i.e. the WORKSPACE
    # file itself) and then use dirname to get the path of the workspace
    # root.
    workspace_file_path = repository_ctx.path(
        Label("@nixpkgs_cc_toolchain//:WORKSPACE"),
    )
    workspace_root = execute_or_fail(
        repository_ctx,
        ["dirname", workspace_file_path],
    ).stdout.rstrip()

    # Make a list of all available tools in the Nix derivation. Override
    # the Bazel autoconfiguration with the tools we found.
    bin_contents = find_children(repository_ctx, workspace_root + "/bin")
    overriden_tools = {
        tool: _readlink(repository_ctx, entry)
        for entry in bin_contents
        for tool in [entry.rpartition("/")[-1]]  # Compute basename
    }
    cc_autoconf_impl(repository_ctx, overriden_tools = overriden_tools)

nixpkgs_cc_autoconf = repository_rule(
    implementation = nixpkgs_cc_autoconf_impl,
    # Copied from
    # https://github.com/bazelbuild/bazel/blob/master/tools/cpp/cc_configure.bzl.
    # Keep in sync.
    environ = [
        "ABI_LIBC_VERSION",
        "ABI_VERSION",
        "BAZEL_COMPILER",
        "BAZEL_HOST_SYSTEM",
        "BAZEL_LINKOPTS",
        "BAZEL_PYTHON",
        "BAZEL_SH",
        "BAZEL_TARGET_CPU",
        "BAZEL_TARGET_LIBC",
        "BAZEL_TARGET_SYSTEM",
        "BAZEL_USE_CPP_ONLY_TOOLCHAIN",
        "BAZEL_DO_NOT_DETECT_CPP_TOOLCHAIN",
        "BAZEL_USE_LLVM_NATIVE_COVERAGE",
        "BAZEL_VC",
        "BAZEL_VS",
        "BAZEL_LLVM",
        "USE_CLANG_CL",
        "CC",
        "CC_CONFIGURE_DEBUG",
        "CC_TOOLCHAIN_NAME",
        "CPLUS_INCLUDE_PATH",
        "GCOV",
        "HOMEBREW_RUBY_PATH",
        "SYSTEMROOT",
        "VS90COMNTOOLS",
        "VS100COMNTOOLS",
        "VS110COMNTOOLS",
        "VS120COMNTOOLS",
        "VS140COMNTOOLS",
    ],
)

def nixpkgs_cc_configure_deprecated(
        repository = None,
        repositories = {},
        nix_file = None,
        nix_file_deps = None,
        nix_file_content = None,
        nixopts = []):
    """Use a CC toolchain from Nixpkgs. No-op if not a nix-based platform.

    Tells Bazel to use compilers and linkers from Nixpkgs for the CC toolchain.
    By default, Bazel auto-configures a CC toolchain from commands available in
    the environment (e.g. `gcc`). Overriding this autodetection makes builds
    more hermetic and is considered a best practice.

    #### Example

      ```bzl
      nixpkgs_cc_configure(repository = "@nixpkgs//:default.nix")
      ```

    Args:
      repository: A repository label identifying which Nixpkgs to use.
        Equivalent to `repositories = { "nixpkgs": ...}`.
      repositories: A dictionary mapping `NIX_PATH` entries to repository labels.

        Setting it to
        ```
        repositories = { "myrepo" : "//:myrepo" }
        ```
        for example would replace all instances of `<myrepo>` in the called nix code by the path to the target `"//:myrepo"`. See the [relevant section in the nix manual](https://nixos.org/nix/manual/#env-NIX_PATH) for more information.

        Specify one of `repository` or `repositories`.
      nix_file: An expression for a Nix environment derivation.
        The environment should expose all the commands that make up a CC
        toolchain (`cc`, `ld` etc). Exposes all commands in `stdenv.cc` and
        `binutils` by default.
      nix_file_deps: Dependencies of `nix_file` if any.
      nix_file_content: An expression for a Nix environment derivation.
      nixopts: Options to forward to the nix command.

    Deprecated:
      Use `nixpkgs_cc_configure` instead.

      While this improves upon Bazel's autoconfigure toolchain by picking tools
      from a Nix derivation rather than the environment, it is still not fully
      hermetic as it is affected by the environment. In particular, system
      include directories specified in the environment can leak in and affect
      the cache keys of targets depending on the cc toolchain leading to cache
      misses.
    """
    if not nix_file and not nix_file_content:
        nix_file_content = """
          with import <nixpkgs> { config = {}; overlays = []; }; buildEnv {
            name = "bazel-cc-toolchain";
            paths = [ stdenv.cc binutils ];
          }
        """
    nixpkgs_package(
        name = "nixpkgs_cc_toolchain",
        repository = repository,
        repositories = repositories,
        nix_file = nix_file,
        nix_file_deps = nix_file_deps,
        nix_file_content = nix_file_content,
        build_file_content = """exports_files(glob(["bin/*"]))""",
        nixopts = nixopts,
    )

    # Following lines should match
    # https://github.com/bazelbuild/bazel/blob/master/tools/cpp/cc_configure.bzl#L93.
    nixpkgs_cc_autoconf(name = "local_config_cc")
    native.bind(name = "cc_toolchain", actual = "@local_config_cc//:toolchain")
    native.register_toolchains("@local_config_cc//:all")

_java_nix_file_content = """\
with import <nixpkgs> { config = {}; overlays = []; };

{ attrPath
, attrSet
, filePath
}:

let
  javaHome =
    if attrSet == null then
      pkgs.lib.getAttrFromPath (pkgs.lib.splitString "." attrPath) pkgs
    else
      pkgs.lib.getAttrFromPath (pkgs.lib.splitString "." attrPath) attrSet
    ;
  javaHomePath =
    if filePath == "" then
      "${javaHome}"
    else
      "${javaHome}/${filePath}"
    ;
in

pkgs.runCommand "bazel-nixpkgs-java-runtime"
  { executable = false;
    # Pointless to do this on a remote machine.
    preferLocalBuild = true;
    allowSubstitutes = false;
  }
  ''
    n=$out/BUILD.bazel
    mkdir -p "$(dirname "$n")"

    cat >>$n <<EOF
    load("@rules_java//java:defs.bzl", "java_runtime")
    java_runtime(
        name = "runtime",
        java_home = r"${javaHomePath}",
        visibility = ["//visibility:public"],
    )
    EOF
  ''
"""

def _nixpkgs_java_toolchain_impl(repository_ctx):
    cpu = get_cpu_value(repository_ctx)
    exec_constraints, target_constraints = ensure_constraints(repository_ctx)

    repository_ctx.file(
        "BUILD.bazel",
        executable = False,
        content = """\
load("@io_tweag_rules_nixpkgs//nixpkgs:toolchains/java/local_java_repository.bzl", "local_java_runtime")
local_java_runtime(
   name = "{name}",
   version = "{version}",
   runtime_name = "@{runtime}//:runtime",
   java_home = None,
   exec_compatible_with = {exec_constraints},
   target_compatible_with = {target_constraints},
)
""".format(
            runtime = repository_ctx.attr.runtime_repo,
            version = repository_ctx.attr.runtime_version,
            name = repository_ctx.attr.runtime_name,
            exec_constraints = exec_constraints,
            target_constraints = target_constraints,
        ),
    )

_nixpkgs_java_toolchain = repository_rule(
    _nixpkgs_java_toolchain_impl,
    attrs = {
        "runtime_repo": attr.string(),
        "runtime_version": attr.string(),
        "runtime_name": attr.string(),
        "exec_constraints": attr.string_list(),
        "target_constraints": attr.string_list(),
    },
)

def nixpkgs_java_configure(
        name = "nixpkgs_java_runtime",
        attribute_path = None,
        java_home_path = "",
        repository = None,
        repositories = {},
        nix_file = None,
        nix_file_content = "",
        nix_file_deps = None,
        nixopts = [],
        fail_not_supported = True,
        quiet = False,
        toolchain = False,
        toolchain_name = None,
        toolchain_version = None,
        exec_constraints = None,
        target_constraints = None):
    """Define a Java runtime provided by nixpkgs.

    Creates a `nixpkgs_package` for a `java_runtime` instance. Optionally,
    you can also create & register a Java toolchain. This only works with Bazel >= 5.0
    Bazel can use this instance to run JVM binaries and tests, refer to the
    [Bazel documentation](https://docs.bazel.build/versions/4.0.0/bazel-and-java.html#configuring-the-jdk) for details.

    #### Example

    ##### Bazel 4

    Add the following to your `WORKSPACE` file to import a JDK from nixpkgs:
    ```bzl
    load("@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl", "nixpkgs_java_configure")
    nixpkgs_java_configure(
        attribute_path = "jdk11.home",
        repository = "@nixpkgs",
    )
    ```

    Add the following configuration to `.bazelrc` to enable this Java runtime:
    ```
    build --javabase=@nixpkgs_java_runtime//:runtime
    build --host_javabase=@nixpkgs_java_runtime//:runtime
    # Adjust this to match the Java version provided by this runtime.
    # See `bazel query 'kind(java_toolchain, @bazel_tools//tools/jdk:all)'` for available options.
    build --java_toolchain=@bazel_tools//tools/jdk:toolchain_java11
    build --host_java_toolchain=@bazel_tools//tools/jdk:toolchain_java11
    ```

    ##### Bazel 5

    Add the following to your `WORKSPACE` file to import a JDK from nixpkgs:
    ```bzl
    load("@io_tweag_rules_nixpkgs//nixpkgs:nixpkgs.bzl", "nixpkgs_java_configure")
    nixpkgs_java_configure(
        attribute_path = "jdk11.home",
        repository = "@nixpkgs",
        toolchain = True,
        toolchain_name = "nixpkgs_java",
        toolchain_version = "11",
    )
    ```

    Add the following configuration to `.bazelrc` to enable this Java runtime:
    ```
    build --host_platform=@io_tweag_rules_nixpkgs//nixpkgs/platforms:host
    build --java_runtime_version=nixpkgs_java
    build --tool_java_runtime_version=nixpkgs_java
    ```

    Args:
      name: The name-prefix for the created external repositories.
      attribute_path: string, The nixpkgs attribute path for `jdk.home`.
      java_home_path: optional, string, The path to `JAVA_HOME` within the package.
      repository: See [`nixpkgs_package`](#nixpkgs_package-repository).
      repositories: See [`nixpkgs_package`](#nixpkgs_package-repositories).
      nix_file: optional, Label, Obtain the runtime from the Nix expression defined in this file. Specify only one of `nix_file` or `nix_file_content`.
      nix_file_content: optional, string, Obtain the runtime from the given Nix expression. Specify only one of `nix_file` or `nix_file_content`.
      nix_file_deps: See [`nixpkgs_package`](#nixpkgs_package-nix_file_deps).
      nixopts: See [`nixpkgs_package`](#nixpkgs_package-nixopts).
      fail_not_supported: See [`nixpkgs_package`](#nixpkgs_package-fail_not_supported).
      quiet: See [`nixpkgs_package`](#nixpkgs_package-quiet).
      toolchain: Create & register a Bazel toolchain based on the Java runtime.
      toolchain_name: The name of the toolchain that can be used in --java_runtime_version.
      toolchain_version: The version of the toolchain that can be used in --java_runtime_version.
      exec_constraints: Constraints for the execution platform.
      target_constraints: Constraints for the target platform.
    """
    if attribute_path == None:
        fail("'attribute_path' is required.", "attribute_path")

    nix_expr = None
    if nix_file and nix_file_content:
        fail("Cannot specify both 'nix_file' and 'nix_file_content'.")
    elif nix_file:
        nix_expr = "import $(location {}) {{}}".format(nix_file)
        nix_file_deps = depset(direct = [nix_file] + nix_file_deps).to_list()
    elif nix_file_content:
        nix_expr = nix_file_content
    else:
        nix_expr = "null"

    nixopts = list(nixopts)
    nixopts.extend([
        "--argstr",
        "attrPath",
        attribute_path,
        "--arg",
        "attrSet",
        nix_expr,
        "--argstr",
        "filePath",
        java_home_path,
    ])

    nixpkgs_package(
        name = name,
        nix_file_content = _java_nix_file_content,
        repository = repository,
        repositories = repositories,
        nix_file_deps = nix_file_deps,
        nixopts = nixopts,
        fail_not_supported = fail_not_supported,
        quiet = quiet,
    )
    if toolchain:
        _nixpkgs_java_toolchain(
            name = "{}_toolchain".format(name),
            runtime_repo = name,
            runtime_version = toolchain_version,
            runtime_name = toolchain_name,
            exec_constraints = exec_constraints,
            target_constraints = target_constraints,
        )
        native.register_toolchains("@{}_toolchain//:all".format(name))

def nixpkgs_sh_posix_config(name, packages, **kwargs):
    nixpkgs_package(
        name = name,
        nix_file_content = """
with import <nixpkgs> {{ config = {{}}; overlays = []; }};

let
  # `packages` might include lists, e.g. `stdenv.initialPath` is a list itself,
  # so we need to flatten `packages`.
  flatten = builtins.concatMap (x: if builtins.isList x then x else [x]);
  env = buildEnv {{
    name = "posix-toolchain";
    paths = flatten [ {} ];
  }};
  cmd_glob = "${{env}}/bin/*";
  os = if stdenv.isDarwin then "osx" else "linux";
in

runCommand "bazel-nixpkgs-posix-toolchain"
  {{ executable = false;
    # Pointless to do this on a remote machine.
    preferLocalBuild = true;
    allowSubstitutes = false;
  }}
  ''
    n=$out/nixpkgs_sh_posix.bzl
    mkdir -p "$(dirname "$n")"

    cat >>$n <<EOF
    load("@rules_sh//sh:posix.bzl", "posix", "sh_posix_toolchain")
    discovered = {{
    EOF
    for cmd in ${{cmd_glob}}; do
        if [[ -x $cmd ]]; then
            echo "    '$(basename $cmd)': '$cmd'," >>$n
        fi
    done
    cat >>$n <<EOF
    }}
    def create_posix_toolchain():
        sh_posix_toolchain(
            name = "nixpkgs_sh_posix",
            cmds = {{
                cmd: discovered[cmd]
                for cmd in posix.commands
                if cmd in discovered
            }}
        )
    EOF
  ''
""".format(" ".join(packages)),
        build_file_content = """
load("//:nixpkgs_sh_posix.bzl", "create_posix_toolchain")
create_posix_toolchain()
""",
        **kwargs
    )

# Note [Target constraints for POSIX tools]
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
# There at least three cases for POSIX tools.
#
# Case 1) The tools are used at build time in the execution platform.
#
# Case 2) The tools are used at runtime time in the target platform
#         when the target platform is the same as the execution
#         platform.
#
# Case 3) The tools are used at runtime time in the target platform
#         when cross-compiling.
#
# At the moment, only (1) and (2) are supported by ignoring any target
# constraints when defining the toolchain. This makes available
# any tools that don't depend on the target platform like grep, find
# or sort. In case (2), the tools are still usable at runtime since
# the platforms match.
#
# POSIX tools that depend on the target platform, like cc and strip,
# are better taken from the Bazel cc toolchain instead, so they do
# match the target platform.
#
# TODO: In order to support (3), where the tools would be needed at
# runtime, nixpkgs_sh_posix_configure will need to be changed to take
# as parameter the constraints for the platform in which the tools
# should run.

def _nixpkgs_sh_posix_toolchain_impl(repository_ctx):
    cpu = get_cpu_value(repository_ctx)
    repository_ctx.file("BUILD", executable = False, content = """
toolchain(
    name = "nixpkgs_sh_posix_toolchain",
    toolchain = "@{workspace}//:nixpkgs_sh_posix",
    toolchain_type = "@rules_sh//sh/posix:toolchain_type",
    exec_compatible_with = [
        "@platforms//cpu:x86_64",
        "@platforms//os:{os}",
        "@io_tweag_rules_nixpkgs//nixpkgs/constraints:support_nix",
    ],
    # Leaving the target constraints empty matter for cross-compilation.
    # See Note [Target constraints for POSIX tools]
    target_compatible_with = [],
)
    """.format(
        workspace = repository_ctx.attr.workspace,
        os = {"darwin": "osx"}.get(cpu, "linux"),
    ))

_nixpkgs_sh_posix_toolchain = repository_rule(
    _nixpkgs_sh_posix_toolchain_impl,
    attrs = {
        "workspace": attr.string(),
    },
)

def nixpkgs_sh_posix_configure(
        name = "nixpkgs_sh_posix_config",
        packages = ["stdenv.initialPath"],
        **kwargs):
    """Create a POSIX toolchain from nixpkgs.

    Loads the given Nix packages, scans them for standard Unix tools, and
    generates a corresponding `sh_posix_toolchain`.

    Make sure to call `nixpkgs_sh_posix_configure` before `sh_posix_configure`,
    if you use both. Otherwise, the local toolchain will always be chosen in
    favor of the nixpkgs one.

    Args:
      name: Name prefix for the generated repositories.
      packages: List of Nix attribute paths to draw Unix tools from.
      nix_file_deps: See nixpkgs_package.
      repositories: See nixpkgs_package.
      repository: See nixpkgs_package.
      nixopts: See nixpkgs_package.
      fail_not_supported: See nixpkgs_package.
    """
    nixpkgs_sh_posix_config(
        name = name,
        packages = packages,
        **kwargs
    )

    # The indirection is required to avoid errors when `nix-build` is not in `PATH`.
    _nixpkgs_sh_posix_toolchain(
        name = name + "_toolchain",
        workspace = name,
    )
    native.register_toolchains(
        "@{}//:nixpkgs_sh_posix_toolchain".format(name + "_toolchain"),
    )
